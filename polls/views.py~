from django.shortcuts import render_to_response
from django.views.generic import View
from django.shortcuts import render, redirect
from django.http import HttpResponse, HttpRequest, Http404
from django.views.decorators.csrf import csrf_exempt
from django.db.models import Count
from django.contrib import auth
from polls.models import Question, Profile, Answer, Tag
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from .forms import *
from django.utils import timezone
from django.contrib.auth.models import User
from django.contrib.auth.decorators import login_required


def index(request):
	context = {}
	context['title'] = "Main Page"
	latest_question_list = Question.objects.annotate(num_answer=Count("answer")).order_by('-pub_date')
	pages = pagination(request, latest_question_list)
	context.update(pages)
	context['profile'] = get_user_data(request)
	context['popular_tags'] = Tag.objects.all().values('id', 'word').annotate(Count("question")).order_by('-question__count')[0:5]	
	context['authors'] = Profile.objects.order_by('-user_reiting')[:10]
	return render(request, 'index.html', context)


def reiting(request):
	context = {}
	context['title'] = "Best Questions"
	latest_question_list = Question.objects.annotate(num_answer=Count("answer")).order_by('-question_reiting')[:100]
	pages = pagination(request, latest_question_list)
	context.update(pages)
	context['profile'] = get_user_data(request)
	context['authors'] = Profile.objects.order_by('-user_reiting')[:10]
	context['popular_tags'] = Tag.objects.all().values('id','word').annotate(Count("question")).order_by('-question__count')[0:5]	
	return render(request, 'index.html', context)


def tags(request, tag_id):
	context = {}	
	try:
		context['tag'] = Tag.objects.get(pk = tag_id)
	except Tag.DoesNotExist:
		raise Http404("Tag does not exist")
	question_list = Question.objects.annotate(num_answer=Count("answer")).filter(tags = tag_id)	
	latest_question_list = question_list.order_by('-question_reiting')
	pages = pagination(request, latest_question_list)
	context.update(pages)
	context['title'] = "Search by tag: "
	context['profile'] = get_user_data(request)
	context['authors'] = Profile.objects.order_by('-user_reiting')[:10]
	context['popular_tags'] = Tag.objects.all().values('id', 'word').annotate(Count("question")).order_by('-question__count')[0:5]	
	return render(request, 'index.html', context)


def question(request, question_id):
	try:
		question = Question.objects.annotate(num_answer=Count("answer")).get(pk=question_id)
	except Question.DoesNotExist:
		raise Http404("Question does not exist")
	context = {}
	context['profile'] = get_user_data(request)
	context['question'] =  question
	context['authors'] = Profile.objects.order_by('-user_reiting')[:10]
	context['answers'] = Answer.objects.filter(question = question_id)
	context['popular_tags'] = Tag.objects.all().values('id', 'word').annotate(Count("question")).order_by('-question__count')[0:5]	
	return render(request, 'question.html', context)


@login_required
def new_q(request):
	context = {}
	context['profile'] = get_user_data(request)
	context['authors'] = Profile.objects.order_by('-user_reiting')[:10]
	context['popular_tags'] = Tag.objects.all().values('id', 'word').annotate(Count("question")).order_by('-question__count')[0:5]	
	form = NewQuestion()		
	if request.POST:
		form = NewQuestion(request.POST)
		context['form'] = form
		if form.is_valid():
			title = form.cleaned_data["title"]
			text = form.cleaned_data["text"]
			tags = form.cleaned_data["tags"].replace(" ", "").split(",")
			q = Question.objects.create(question_title = title, question_text = text, author = Profile.objects.get(user_id=request.user), pub_date = timezone.now())
			q.save()
			for t in tags:
				if len(t) > 0:
					try:
						tn = Tag.objects.get(word=str(t).lower())
					except Tag.DoesNotExist:
						tn = Tag.objects.create(word=str(t).lower())
					q.tags.add(tn)
			return redirect('/')
		else:
			return render(request, 'new_q.html', context)
	else:
		context['form'] = form
	return render(request, 'new_q.html', context)


@login_required
def answer(request, question_id):
	if request.POST:
		text = request.POST['answer']
		#if(len(text) > 10)
		#	try:

		#	except

	return redirect(reverse('question', kwargs = {'question_id': question_id} ))
	

def login(request):
	context = {}
	context['authors'] = Profile.objects.order_by('-user_reiting')[:10]
	context['popular_tags'] = Tag.objects.all().values('id', 'word').annotate(Count("question")).order_by('-question__count')[0:5]	
	if request.POST:
		name = request.POST['username']
		password =  request.POST['password']
		user  = auth.authenticate(username=name, password=password)
		if user is not None:
			auth.login(request, user)
			return redirect('/')
		else:
			return render(request, 'login.html', {"login_error": True} )
	return render(request, 'login.html', context)


def logout_view(request):
	auth.logout(request)
	return redirect('/')

def reg(request):
	context = {}
	context['authors'] = Profile.objects.order_by('-user_reiting')[:10]
	context['popular_tags'] = Tag.objects.all().values('id', 'word').annotate(Count("question")).order_by('-question__count')[0:5]	
	form = ProfileUser()		
	if request.POST:
		form = ProfileUser(request.POST)
		context['form'] = form
		if form.is_valid():
			password =  form.cleaned_data.get('password')
			password2 =  form.cleaned_data.get('passwordSecond')
			if password2 != password:
				context['error'] = "Passwords are different!"
				return render(request, 'register.html', context)
			name = form.cleaned_data.get('username')
			mail = form.cleaned_data.get('mail')
			nick = form.cleaned_data.get('nick')
			try:
				u = User.objects.create(username = name, email = mail )
				u.set_password(password)
				u.save()
				p = Profile.objects.create(user_id = u, user_name = nick, user_reiting = 5)
				p.save()
			except:
				context['error'] = "Cann't create user"
				return render(request, 'register.html', context)
			context['title'] = "Congratulations! "
			context['message']='New user has been created successfully! You can login now'
			return render(request, 'message.html', context)
		else:
			return render(request, 'register.html', context)
	else:
		context['form'] = form	
	return render(request, 'register.html', context)

@login_required
def get_user_data(request):
	context = {}
	prop = Profile.objects.get(user_id=request.user.id)
	context["id"] = request.user.id
	context["nickname"] = prop.user_name
	context["avatar"] = prop.avatar
	return context


def pagination(request, objects):
	context = {}
	limit = 5
	pager = Paginator(objects, limit) 
	page = request.GET.get('page', 1)
	try:
		context['quaryset'] = pager.page(page)
	except PageNotAnInteger:
        # If page is not an integer, deliver first page.
		page = 1
		context['page'] = 1
		context['quaryset'] = pager.page(page)
	except EmptyPage:
        # If page is out of range (e.g. 9999), deliver last page of results.
		page = pager.num_pages	
		context['page'] = page
		context['queryset'] = pager.page(page)
	context['questions'] = pager.page(page).object_list
	context['pager'] = pager
	context['minPageNum'] = int(page) - 3
	context['maxPageNum'] = int(page) + 3
	return context
